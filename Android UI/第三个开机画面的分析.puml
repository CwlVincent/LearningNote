@startuml

title 第三个开机画面的显示和停止的分析

fork

:<b><size:20>第三个开机画面由应用程序bootanimation来负责显示的</size></b>;

note right : 应用程序bootanimation的用户和用户组名称分别被设置为graphics，注意，用来启动应用程序的bootanimation的服务是disable，即init进程在启动的时候，不会主动将应用程序bootanimation启动起来。

start

:SurfaceFlinger服务启动，修改系统属性ctl.start的值通知init进程启动应用程序bootanimation，便可以显示第三个开机画面;

:当System进程将系统中的关键服务都启动起来;

:ActiviyManagerService服务就会通知SurfaceFlinger服务来修改系统ctl.stop的值，以便于通知init进程停止执行应用程序bootanimation，即停止第三个开机画面;




fork again

:<b><size:20>第三个开机画面的显示的初始化</size></b>;

start 

:Zygote进程在启动过程中，会将System进程启动起来;

:System进程在启动过程中，会调用SurfaceFlinger类的静态成员函数instantiate来启动SurfaceFlinger服务;

:System进程在启动SurfaceFlinger服务的过程中，先创建一个SurfaceFlinger实例，再将这个实例注册到Service Manager中去;

:在注册的过程中，SurfaceFlinger实例会被sp指针引用,调用成员函数onFirstRef，启动一个线程来启动第三个开机画面;
note right : 当一个对象第一次被智能指针引用的时候，这个对象的成员函数onFirstRef就会被调用，由于SurfaceFlinger重写了父类的RefBase的成员函数onFirstRef。

:SurfaceFlinger继承了Thread类，onFirstRef中会调用run的成员函数，系统就会创建一个新的线程，在这个线程第一次运行之前，会调用SurfaceFlinger类的成员函数readyToRun来通知SurfaceFlinger，它准备就绪了;

note right : SurfaceFlinger在4.0以上的话，就在SurfaceFlinger::init启动bootanim服务，并在SurfaceFlinger::selectEGLConfig初始化，在4.0及以下的就在readyToRun中，初始化OPENGL，并启动服务,这里是4.0以下的代码分析。

:当这个线程准备就绪之后，就会循环执行SurfaceFlinger类的成员函数threadLoop，知道这个成员函数的返回值等于false为止;

note right : SurfaceFlinger类的成员函数onFirstRef是在System进程的主线程中调用的，它需要等待前面创建的线程准备就绪之后，再继续往前执行，这个通过调用SurfaceFlinger类的成员变量mReadytoRunBarrier所描述的一个Barrier对象的成员函数wait来实现的。每一个Barrier对象内都封装了一个条件变量(Condition Variable),而条件变量是用来同步线程的。

:readyToRun函数中，会对设备主屏幕以及OpenGL库进行初始化，并唤醒System进程的主线程，以便于它可以继续往前执行;

:readyToRun函数中，调用函数property_set将系统属性"ctl.start"的值设置为"bootanim"，表示要启动应用程序bootanimation;

:当系统属性发送改变时，init进程接收到通知之后，调用函数handle_property_set_fd来处理的;

note right : init进程通过socket来接收系统属性变化的事件。每一个系统属性变化的事件的内容同时通过pro_msg对象来描述的。在prop_msg对象对，成员变量name表示属性的名称，value表示属性的值。系统属性分为两种类型，一种是普通类型，一种是控制类型，改变系统属性需要权限，会在handle_proerty_set_fd处理通过check_control_perms或者check_perms检查是否具有相应的权限。

:当前发送变化的系统属性名称为"ctl.start",值为bootanim，会通过msg_start或者msg_stop来启动bootanim服务，msg_start会调用service_find_by_name来找到"bootanim"的服务信息，保存到service结构体svc中，并调用函数service_start启动对应的服务;


fork again

:<b><size:20>BootAnimation显示初始化的分析</size></b>;

start 

if("系统属性debug.sf.nobootnimation的值是否不等于") then (N)

:启动Binder线程池，并创建一个BootAnimation对象;

:BootAnimation间接继承RefBase，并且重写RefBase类的成员函数onFirstRef，因此当一个BootAnimation对象第一次被智能指针引用时，这个BootAnimation对象的成员函数onFirstRef就会被调用;

:在onFirstRef函数中，使用SurfaceComposerClient类来关联SurfaceFlinger服务的意外死亡通知;

:BootAnimation继承了Thread类，重写了run，所以在run之前会调用readyToRun，进行一些初始化的工作，最后再调用threadLoop来显示第三个开机画面;

:readyToRun中，SurfaceComposerClient中createSurface创建内部Binder代理SurfaceLayer，来和SurfaceFlinger服务通信;

note right : 调用SurfaceControl对象的control的成员函数getSurface会返回一个Surface对象s。这个Surface对象s内部也有一个类型为SurfaceLayer的Binder代理对象mSurface，这个和之前的SurfaceLayer是同一个，这样Surface对象s也可以通过其内部的Binder代理对象mSurface和SurfaceFlinger服务通信, Surface类继承了ANativeWindow类。ANativeWindow类是连接OpenGL和Android窗口系统的桥梁，即OpenGL需要通过ANativeWindow类来间接地Android窗口系统。这种桥梁关系是通过EGL库来建立的，所有以egl为前缀的函数名均为EGL库提供接口。

:根据BootAnimation类的成员变量mAndroidAnimation是一个布尔变量，当它的值等于true的时候，那么就说明需要显示的第三个开机画面是Android系统默认的开机动画，否则的话，第三个开机画面是用户自定义的开机动画，到此为止线程的初始化工作就执行完成了;

note right : 每一个EGLSurface对象surface有一个关联的ANativeWindow对象。这个ANativeWindow对象是通过函数eglCreateWindowSurface的第三个参数来指定的。在这个场景中，这个ANativeWindow对象正好对应于前面创建的Surface对象。每当OpenGL需要绘图的时候，就会找到前面所设置的绘图表面，即EGLSurface对象surface。有了EGLSurface对象surface之后，就可以找到与它关联的ANativeWindow对象，即Surface对象s。有了Surface对象s之后，就可以通过其内部的Binder代理对象mSurface来请求SurfaceFlinger服务返回帧缓冲区硬件设备的一个图形访问接口。这样，OpenGl最终就可以将要绘制的图形渲染到帧缓冲区硬件设备中区，即显示在屏幕上。屏幕的大小，即宽度和高度，可以通过函数eglQuerySurface来获得。


fork again

:<b><size:20>BootAnimation的成员函数threadLoop的分析</size></b>;

start

if("mAndroidAnimation等于true") then (Y)
	
	:调用成员函数android来显示系统默认的开机动画;
	
	:调用initTexture将两张图片内容分别创建两个纹理对象，通过混合渲染两个纹理对象，得到一个开机画面;

	:android-logo-mask.png作为动画前景，是一个镂空的Android图像，android-logo-mask.png作为动画背景，中间包含呈45度的条纹。在每一次循环中，android-logo-shine.png图片被划分成左右两个部分内容来显示。左右两个部分的图像宽度随着时间的推移而此消彼长，这样就可以使得图片android-logo-shine.png中间的高亮条纹好像在移动一样。由于它是一个镂空的ANDROID图像，就可以看到条纹一闪一闪地划过;

	:这个while循环语句会一直被执行，直到应用程序/system/bin/bootanimation被结束为止;

else (N)
	
	:调用成员函数movie来显示用户自定义的开机画面;

	:如果目标设备存在压缩文件/data/local/bootanimation.zip，那么BootAnimation类的成员变量mZip就会指向他，否则的话，就会指向目标设备上的压缩文件/system/media/bootanimation.zip;

	note right : 每一个压缩文件都包含一个名称为"desc.txt"的文件，用来描述用户自定义的开机动画是如何显示的

	:for循环语句分析完desc.txt文件的内容后，就得到了开机动画的显示大小、速度以及片断信息，都保存到Animation对象animation，其中，每一个动画片断都使用一个Animation::Part对象来描述，并且保存在Animation对象animation的成员变量parts所描述的一个片断列表中;

	:成员函数movie再断续将每一个片断所对应的png图片读取出来;

endif
 
end fork

@enduml